# Understanding Commands and Subagents in Claude Code

## Main Agent vs Subagents: Roles and Communication

**Claude Code’s Main Agent** is the primary AI assistant that interacts with you in the terminal. It has a broad view of your project and can perform various actions (reading files, editing, running commands, making commits, etc.) under your guidance[\[1\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,let%20you%20scale%20reliable%2C%20repeatable). By default, all interactions (except when you explicitly call a subagent or command) go through this main agent.

**Subagents** are specialized “mini-agents” you define, each with its own system prompt, tool permissions, and **independent context window**[\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows). They serve as task-specific assistants (e.g. a code reviewer, test runner, debugger) to which the main agent can delegate work. The main agent will **“call” a subagent for a subtask**, the subagent will work in isolation on that task, and then it **returns the result** to the main agent[\[3\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior). This delegation is analogous to a function call: the main agent hands off a specific job to a subagent and waits for its output, which it then integrates into the overall session.

**Key characteristics of subagents**:

* **Specialized Expertise:** Each subagent has a focused role or domain (defined by you in its prompt). For example, you might have a code-reviewer subagent for code quality review, or a test-runner for running and fixing tests[\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows).

* **Isolated Context:** A subagent operates with its **own context window**, separate from the main conversation[\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows). This prevents the main chat from getting “polluted” with details of the subtask and ensures the subagent remains focused. The subagent does not automatically receive the entire main chat history – it essentially sees only what is provided to it (its system prompt plus the immediate task details) and has its own memory limited to that context.

* **Custom System Prompts:** Each subagent has a tailor-made system prompt (the content of its Markdown file) that defines its behavior, style, and approach. This prompt guides the subagent to perform its specific task reliably and consistently.

* **Limited Tool Access:** You can restrict what tools a subagent is allowed to use. For example, a review subagent might only be permitted to read and search (Read, Grep tools) but not to write files, whereas a coding subagent could have edit/write permissions[\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94). This enhances security and safety by sandboxing what each subagent can do (e.g. a reviewer can’t accidentally modify code)[\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94).

* **Delegation by Main Agent:** The main agent decides when to hand off to a subagent. When it detects that a user request matches a subagent’s purpose, it can **delegate the task to that subagent** automatically[\[5\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior). The subagent performs the work (using its own prompt and allowed tools) and **returns the results to the main agent**[\[3\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior). The main agent then incorporates those results into the conversation (often transparently, as part of its answer to you).

* **No Direct User Interaction:** You, as the user, don’t chat with subagents one-on-one. All communication flows through the main agent. In other words, a subagent doesn’t produce output directly to your terminal; it sends its output back to the main agent, which then relays it (or uses it to continue the process). This is why subagents help maintain the main thread’s focus – the main agent only shares the relevant outcomes, not the entire sub-conversation, unless it’s part of the answer.

Overall, **subagents act like extensions of the main agent** for specialized tasks. The main agent is the “manager” orchestrating high-level goals, and subagents are like “employees” handling well-defined subtasks. This separation makes the system more reliable and context-aware: e.g. your code-review subagent never forgets it’s reviewing code (since its context is isolated to that role), and your main agent can remain focused on the bigger picture without dragging in all the low-level detail of, say, test outputs[\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows).

## Defining and Configuring Subagents (Scope and Setup)

Claude Code makes it easy to create custom subagents. Subagents are defined by Markdown files with a YAML frontmatter header that specifies their configuration[\[6\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure). There are two levels of scope for these agent definition files:

* **Project subagents:** Stored in the project’s .claude/agents/ directory. These are **only available in that project** and can be shared via your repository (checked into version control). Project agents have higher priority if a name overlaps with a user agent[\[7\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20are%20stored%20as%20Markdown,frontmatter%20in%20two%20possible%20locations).

* **User (personal) subagents:** Stored in \~/.claude/agents/ in your home directory. These are **globally available across all projects** for your user. They are not project-specific. If a project defines an agent with the same name as one of your user agents, the project version will take precedence (to ensure project-specific customizations override global ones)[\[8\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Type%20Location%20Scope%20Priority%20Project,claude%2Fagents%2F%60Available%20across%20all%20projects%20Lower).

Each subagent Markdown file should follow this structure[\[6\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure):

\---  
name: \<subagent-name\>  
description: \<When or why Claude should use this subagent\>  
tools: \<optional comma-separated list of tools\>  
\# (Newer versions may also support a model field to pick a specific model version)  
\---

\<Subagent's system prompt instructions...\>

* **name:** A unique identifier for the subagent (all lowercase, hyphens allowed). This is how you refer to the subagent (in conversation or when invoking it)[\[9\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields).

* **description:** A natural language description of the subagent’s purpose and **when it should be invoked**[\[9\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields). This is critical – Claude uses this to decide if a task “matches” the subagent. For example: "Expert code review specialist. Proactively reviews new code for quality and security issues." Keep this description succinct but clear, as it acts like a trigger condition.

* **tools:** (Optional) A list of tools the subagent is allowed to use. Tools are the capabilities like file read/write, running bash commands, etc. If you **omit** tools, the subagent will inherit **all tools** available to the main agent (including any connected Model Context Protocol tools)[\[10\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,agents). If you specify tools, it will have access **only** to those listed (nothing more)[\[11\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,tools%20from%20the%20main%20thread). For instance, you might list Read, Grep, Glob for a read-only agent. This fine-grained control lets you sandbox subagents for safety[\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94).

* **model:** (Optional, if supported in your version) By default, subagents use the same model as the main agent. Recent Claude Code updates have introduced the ability to choose the model per subagent (e.g., using a larger model like Claude 2 “Opus” for complex planning subagents, or a faster/smaller model for simple tasks)[\[12\]](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/#:~:text=needing%20to%20run%20a%20full,and%20losing%20important%20project%20context). In the /agents UI, you may see an option to set the model, or you can add a model: opus (for Claude 2\) or model: haiku (for Claude Instant) in the frontmatter if supported. This allows optimizing each subagent’s performance and context window as needed[\[12\]](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/#:~:text=needing%20to%20run%20a%20full,and%20losing%20important%20project%20context).

* **System prompt (body):** After the \--- that ends the YAML frontmatter, the rest of the file is the **subagent’s prompt**. This should **clearly define the subagent’s role, behavior, and approach** in detail[\[13\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,all%20tools%20if%20omitted). Essentially, you’re instructing that subagent how to do its job. You can include multiple paragraphs of guidelines, sample steps, or checklists in this prompt. For example, a “code-reviewer” subagent’s prompt might outline a checklist of code quality items to look for and the format for reporting issues[\[14\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Code%20reviewer)[\[15\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Review%20checklist%3A%20,Performance%20considerations%20addressed). A “debugger” subagent’s prompt might describe a systematic debugging process[\[16\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Debugger)[\[17\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Debugging%20process%3A%20,Inspect%20variable%20states). This prompt is like the persona and knowledge of the subagent – be specific about what you expect it to do and not do.

**How to create/edit subagents:** You can create subagent files manually or use an interactive interface:

* **Interactive:** In a Claude Code session, run the command /agents. This brings up a menu where you can list existing agents and “Create New Agent” easily[\[18\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Using%20the%20%2Fagents%20command%20). The interface will prompt you for the name, description, allowed tools, etc., and even let Claude draft an initial prompt for you (you can press e to edit the generated prompt in your editor)[\[19\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Define%20the%20subagent). This is a convenient way to ensure proper formatting. The /agents UI also allows editing or deleting subagents later[\[20\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=This%20opens%20an%20interactive%20menu,where%20you%20can).

* **Manual:** Create the file under .claude/agents/ (project) or \~/.claude/agents/ (user). For example, to make a project-level agent called “test-runner”, you would do:

mkdir \-p .claude/agents  
nano .claude/agents/test-runner.md

*(paste or write the YAML and prompt content, then save)*

The example below creates a simple test-runner agent via shell commands:

mkdir \-p .claude/agents  
echo '---  
name: test-runner  
description: Use proactively to run tests and fix failures  
\---  
You are a test automation expert. When you see code changes, proactively run the appropriate tests. If tests fail, analyze the failures and fix them while preserving the original test intent.' \> .claude/agents/test-runner.md

This would define a test-runner subagent with the given prompt[\[21\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,tests%20and%20fix%20failures). (In practice, it’s easier to use /agents or a text editor than a single echo command, but this illustrates the format.)

Once the Markdown files are in place, **Claude Code loads subagents when it starts a session**. The available subagents (built-in \+ custom) are typically shown in the /agents list. **If you update or add a subagent file, you will need to restart the Claude Code session to have it pick up the changes**[\[22\]](https://github.com/anthropics/claude-code/issues/4986#:~:text=Currently%2C%20subagents%20are%20only%20loaded,having%20to%20restart%20Claude%20Code). Currently, subagent definitions are *not* dynamically reloaded in the middle of a session – they are read at startup. (A feature request exists for dynamic mid-session loading, but as of now you should restart to apply changes[\[22\]](https://github.com/anthropics/claude-code/issues/4986#:~:text=Currently%2C%20subagents%20are%20only%20loaded,having%20to%20restart%20Claude%20Code).)

**Tip:** Use clear, descriptive names for your agents and keep their descriptions focused on the trigger conditions. If two agents have similar domains, delineate when each should be used in their descriptions. Also, version control your project agents along with your code – this allows your team to share standardized subagents (the subagent files can be committed just like code, improving team workflows)[\[23\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=reviewer%20can%20read%2Fgrep%2C%20coder%20can,the%20natural%20unit%20for%20that).

## Invoking Subagents: Automatic Delegation vs Explicit Use

Once you have subagents configured, **Claude’s main agent can invoke them in two ways**: automatically or explicitly on command.

**1\. Automatic delegation (proactive use):** Claude Code will **proactively delegate tasks** to a subagent when it believes that subagent is well-suited for the request you just made. It decides this based on the subagent’s description field and the current task/context[\[5\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior). For example, if you have a code-reviewer agent with description “Expert code review specialist, use immediately after writing or modifying code,” and you say *“Review the code I just wrote for any issues”*, Claude may automatically route that to the code-reviewer subagent. The benefit is that the subagent’s separate context is used (keeping the main chat cleaner) and its specialized prompt likely yields a better result for that task.

* You can **encourage** Claude to use a subagent automatically by phrasing the description strongly. The docs suggest using terms like **“use proactively”** or **“MUST be used”** in the subagent’s description to signal that whenever possible, Claude should delegate relevant tasks to this agent[\[24\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Claude%20Code%20proactively%20delegates%20tasks,based%20on). Essentially, you’re telling Claude “if you see a fitting situation, *please* hand it off to this agent.” For instance: description: Debugging specialist for test failures. Use PROACTIVELY when encountering failing tests.

* Claude evaluates the user’s prompt against these descriptions. If a match is found, it will spawn the subagent behind the scenes. You won’t necessarily see a message like “Switching to subagent X”; Claude will simply output the result that the subagent produced (possibly integrated into a larger answer).

* **Context handling:** When automatically delegating, Claude will pass along any necessary info for the subagent to do its job. This could include a summary of the immediate user request or relevant file diffs, etc. The subagent does *not* automatically get the entire chat history or CLAUDE.md – only what’s needed or what you explicitly provided in your request.

**2\. Explicit invocation (on demand):** You can directly tell Claude to use a particular subagent in your instruction. This is done in natural language by mentioning the subagent by name, usually with a phrase like **“Use the \<name\> subagent to …”**. Claude will recognize this and trigger that subagent immediately, rather than solving it itself[\[25\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Explicit%20invocation). Some examples of explicit invocation:

* *“Use the* *test-runner* *subagent to run my test suite and fix any failures.”* – This instructs Claude to hand off to the test-runner agent to execute tests and patch failures[\[25\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Explicit%20invocation).

* *“Have the* *code-reviewer* *subagent look at my recent changes.”* – This will call the code-reviewer agent to review your latest code diff[\[25\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Explicit%20invocation).

* *“Ask the* *debugger* *subagent to investigate this error.”* – This directs Claude to let the debugger agent handle an error analysis task[\[25\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Explicit%20invocation).

In each case, you explicitly named the agent and thereby invoked it. The main agent will acknowledge this by delegating to that subagent. The outcome will be that subagent’s work (e.g. a test report and code fixes, a code review report, a debug diagnosis) presented as the assistant’s answer.

**New “@” mention feature:** Recent updates have introduced an **@-mention syntax to guarantee subagent usage**. If you prefix a subagent’s name with @ in your prompt, Claude will ensure that subagent is invoked[\[12\]](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/#:~:text=needing%20to%20run%20a%20full,and%20losing%20important%20project%20context). For example: *“@code-reviewer Can you check the security of this new function?”* would force the code-reviewer agent to handle the request. This is a shorthand way to explicitly target subagents and can be useful if you want to be absolutely sure a certain agent (and not the main agent) handles a query. The @-mention is essentially an explicit trigger.

Whether automatic or explicit, **once a subagent is invoked, it operates independently using its own prompt and tools**. It may run shell commands, read files, etc., as allowed, but all those actions are confined to what you permitted for that agent. The subagent will produce an answer or result, which is then returned to the main agent. From your perspective, you simply get a solution to your request. For instance, if you said “Use the test-runner subagent to run tests,” the next thing you see might be the subagent’s summary of test results and applied fixes as if Claude responded with that information. Under the hood, Claude essentially did: *call subagent \-\> get result \-\> present result*.

**Communication flow:** The subagent does not carry on a multi-turn conversation with you. It handles the one task it was given and stops. If further interaction is needed, the main agent will either call it again or handle it itself. Think of it as the main agent saying “Here, specialist, take this and come back when you’re done.” This means if you need an iterative process (like multiple steps), you might invoke subagents multiple times or have a slash command that sequences them (discussed in Advanced Patterns below).

**Parallelism:** It’s important to note that **Claude Code does not run multiple subagents truly in parallel within a single session**. Even though each subagent has an isolated context, the **execution of tasks is sequential** in the REPL (read–eval–print loop). The main agent will delegate to a subagent and wait for it to finish before doing anything else. If your workflow could benefit from concurrency (for example, running tests in the background while generating code), the current solution is to run another Claude Code session in parallel (like in another terminal or CI pipeline)[\[26\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=In%20a%20single%20Claude%20Code,%E2%80%9CSubagent%20Stop%E2%80%9D%20hooks%20are%20described). Within one session, subagent calls and tool uses happen turn-by-turn in a single thread of execution[\[26\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=In%20a%20single%20Claude%20Code,%E2%80%9CSubagent%20Stop%E2%80%9D%20hooks%20are%20described). This is by design to maintain order and avoid conflicts, but it’s a limitation if you hoped for parallel task execution.

## Custom Slash Commands in Claude Code

In addition to subagents, Claude Code provides **slash commands** (prefixed with /) as a mechanism to control or prompt the AI in structured ways. Slash commands can be thought of as **predefined prompts or actions** that you can invoke quickly. There are built-in slash commands for common control tasks, and you can define your own custom commands to extend Claude Code’s capabilities.

**Built-in slash commands:** These come with Claude Code and let you do things like manage settings, view help, clear the conversation, etc. For example, /help shows usage help, /clear clears the conversation history, /agents opens the subagent manager, /memory lets you edit the CLAUDE.md memory, /permissions to adjust tool permissions, etc[\[27\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Built). Built-ins are always available and have reserved names (you can’t override them with custom commands).

**Custom slash commands:** You can create your own commands and tailor them to your workflow. A custom command is defined by a Markdown file (just like subagents) but placed in a commands directory. The content of the file is the prompt that will be executed when you call the command. This is powerful for encapsulating frequently used prompts or multi-step instructions.

**Scope and file locations for commands:**

* **Project-specific commands:** Stored under .claude/commands/ in your repository. These are shared with anyone who has the repo (and appear with “(project)” in the /help list)[\[28\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Project%20commands)[\[29\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Commands%20stored%20in%20your%20repository,project%29%E2%80%9D%20after%20their%20description). Use these for commands that are relevant to this project specifically.

* **Personal (user) commands:** Stored under \~/.claude/commands/ in your home directory. These are available in all projects for your user (shown with “(user)” in /help)[\[30\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Personal%20commands). Use these for more general commands you want everywhere. Team members won’t have your personal commands unless they create similar ones, so personal commands are for your own convenience.

The **command name** is derived from the filename. For example, a file named optimize.md in .claude/commands/ defines a /optimize command[\[31\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Location%3A%20). If you organize commands in subfolders, those become namespaces: e.g. a file .claude/commands/frontend/component.md becomes a command /frontend:component[\[32\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Conflicts%20between%20user%20and%20project,base%20file%20name%20can%20coexist). This namespacing helps group commands logically. Note that **you cannot have two commands with the exact same name in user and project scope** – if such a conflict exists, Claude might not accept it or only one will be listed (the docs note that conflicts between user-level and project-level commands are not supported)[\[33\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Organize%20commands%20in%20subdirectories,level%20directory%20%28%60~%2F.claude%2Fcommands). So ensure unique names or use namespacing to differentiate.

**Defining a custom command:** A command file can be very simple – it might just contain a prompt. The general syntax is:

/\<command-name\> \[arguments\]

Where \<command-name\> comes from the file name (minus .md), and optional \[arguments\] are any extra words/numbers you type after the command. Those arguments can be captured inside your command prompt using a special placeholder.

For example, let's create a project command to optimize code:

1. Create the commands folder (if not already existing):

* mkdir \-p .claude/commands

2. Create a file named optimize.md in that folder with the content:

* Analyze this code for performance issues and suggest optimizations:

* Now, in Claude Code, if you type /optimize while looking at a piece of code, Claude will execute that prompt (possibly considering the file you have open or last referenced). The output will be as if you asked: *"Analyze this code for performance issues and suggest optimizations."*.

Typically, you’ll want your command to be a bit more dynamic or descriptive. Here are some **features of custom commands**:

* **Arguments via $ARGUMENTS:** You can make your command accept arguments by including the token $ARGUMENTS in the markdown content. When you run /yourcommand something here, whatever you typed after the command name will replace $ARGUMENTS in the prompt[\[34\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Arguments). For instance, you might have a file fix-issue.md with content: *“Fix issue \#$ARGUMENTS following our coding standards.”*[\[35\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A). Then running /fix-issue 123 will turn into *“Fix issue \#123 following our coding standards.”* for Claude[\[36\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=,issue.md). This is great for templating common tasks (like a command that takes an issue/ticket number or a filename as an argument).

* **Bash commands in prompts (\! syntax):** One powerful feature is you can run shell commands *as part of your command prompt* to gather context. By prefixing a line with \!, Claude Code will execute that bash command *immediately* when you call the slash command, and include its output in the prompt context[\[37\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Execute%20bash%20commands%20before%20the,specific%20bash%20commands%20to%20allow). For example, you might have in your command:

* \---  
  allowed-tools: Bash(git diff:\*), Bash(git status:\*)  
  \---  
  \#\# Context  
  \- Current git status: \!\`git status\`  
  \- Diff of current branch vs main: \!\`git diff main...\`

  \#\# Task  
  Analyze the above diff for potential issues.

* When you run this command, Claude Code will run git status and git diff behind the scenes (because of the \! lines) and substitute those lines with the actual output of the commands, before giving the whole prompt to Claude[\[38\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=). The allowed-tools frontmatter here is crucial – it whitelists exactly which bash commands can be run (git status, git diff in this case)[\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A). Claude Code’s sandbox will not execute shell commands from a prompt unless they are explicitly allowed. So whenever you use \! in a command file, you must include an allowed-tools field listing Bash(\<command pattern\>) for each command you intend to run (wildcards \* are supported to allow variants)[\[37\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Execute%20bash%20commands%20before%20the,specific%20bash%20commands%20to%20allow)[\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A). This ensures safety (the AI can’t run arbitrary commands, only those you permitted).

* **File references with @:** Similar to how you can mention files in normal conversation, in command prompts you can use the @filename syntax to **inject the contents of a file** directly[\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references). For instance, your command might say: *“Review the implementation in @src/utils/helpers.js”*. When the command runs, that line will be expanded to include the full text of src/utils/helpers.js in the prompt (formatted appropriately). You can reference multiple files too: *“Compare @src/old-version.js with @src/new-version.js”*[\[41\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=). This is extremely useful for commands that need to bring in code context. Instead of manually copy-pasting code or relying on Claude to find the right file, you explicitly feed the file(s) into the prompt. Using @ is much faster than asking Claude to open or read a file itself – it’s essentially an immediate include of content.

* **Extended thinking mode:** If you want Claude to take extra “thinking” steps or ensure it’s thorough, certain keywords (Anthropic has some reserved phrases) can trigger extended reasoning mode. Including these in your command prompt can make Claude produce more detailed chain-of-thought or step-by-step outputs[\[42\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Thinking%20mode). (For example, prefixing with something like “Let’s think this through step by step:” might encourage a more detailed reasoning.)

* **Frontmatter options:** Command files can include YAML frontmatter (just like subagents) to tweak their behavior:

* **allowed-tools:** As discussed, lists which tools the AI is allowed to use during this command’s execution. If omitted, the command inherits whatever tools are currently permitted in the conversation/session. If your command needs to run specific Bash(...) commands or use the Edit tool, etc., you should list them here to avoid being prompted each time or being denied. For example, allowed-tools: Bash(git add:\*), Bash(git commit:\*), Edit would allow those actions when the command runs[\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A).

* **argument-hint:** A hint string that describes the expected arguments, used for autocompletion help. For instance argument-hint: \[issue-number\] \[optional-description\] will show in the UI so you know how to use the command. It doesn’t affect functionality, just helps the user.

* **description:** A one-line description of what the command does. This is what shows up when you type /help or when you trigger autocomplete for / commands in the terminal. By default, if you don’t provide a description frontmatter, Claude Code will take the first line of your prompt content as the description[\[43\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=%3A,Inherits%20from%20the%20conversation). It’s usually better to specify a clean description in frontmatter for clarity.

* **model:** You can specify which model to use for this command if you want it to differ from the default model of the session (options are typically opus for Claude 2, sonnet or haiku for smaller models, or a specific version string)[\[44\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=command.%20Example%3A%20%60argument,Inherits%20from%20the%20conversation). For example, model: haiku in a command frontmatter would force that command to run with the Claude Instant model (faster, lower context) which might be enough for simple tasks and save tokens[\[44\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=command.%20Example%3A%20%60argument,Inherits%20from%20the%20conversation). Or you might use model: opus on a command that does a heavy analysis to ensure it can use the larger context window.

Putting it together, here’s a sample **command definition** with frontmatter:

\---  
allowed-tools: Bash(git add:\*), Bash(git status:\*), Bash(git commit:\*)  
argument-hint: \[message\]  
description: Create a git commit  
model: haiku  
\---

\#\# Context

\- Current git status: \!\`git status\`  
\- Current git diff (staged and unstaged changes): \!\`git diff HEAD\`  
\- Current branch: \!\`git branch \--show-current\`  
\- Recent commits: \!\`git log \--oneline \-10\`

\#\# Your task

Based on the above changes, create a single git commit with the message: "$ARGUMENTS"

This command (let’s say we saved it as .claude/commands/git/commit.md, which becomes /git:commit) will gather the Git status and diff, then prompt Claude to make a commit with the message you provide as argument[\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A)[\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references). The allowed-tools ensures Claude can run those git commands without asking permission each time.

To use it, you’d type something like:  
/git:commit "Fix bug in user login flow"  
Claude would execute the git status and git diff commands, include their outputs, then proceed to draft a commit (likely by staging changes and running the appropriate Git commands, since they are allowed).

**Using slash commands:** In the terminal, you invoke them by typing /commandName arguments... just like using a CLI tool. Claude will then execute the content of that command file as if you had written all that prompt manually. This saves time and enforces consistency. All custom commands you create will be listed under /help (with a tag indicating if they are user or project commands).

**Note:** Just like subagents, custom commands defined in files are loaded at startup. If you add a new command or edit one while Claude Code is running, you may need to restart (or use a /reload if it exists) to see the new command take effect. There isn’t currently an in-session refresh for commands aside from restarting the session.

## Tools, Permissions, and Safety Considerations

Both subagents and slash commands tie into Claude Code’s **tool system**. Tools are actions the AI can take on your behalf, like reading a file, writing to a file, executing a shell command, searching with grep, etc. Understanding tool scope is important for advanced usage:

* The main agent and subagents operate under a **permissions model**. By default, when Claude tries to use a risky tool (like writing files or running a new bash command), it will ask for user approval. You can pre-approve certain tools or commands via settings or the CLI (\--allowedTools flag) to streamline the process[\[45\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=AnthropicClaudeLog%20,CLAUDE.md). For example, you might start Claude with claude \--allowedTools "Read" "Grep" "Glob" to allow reading and searching without prompts.

* Subagents can have **different allowed tools** than the main agent. This segmentation can enforce security boundaries[\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94). For instance, you might allow your main agent to use Edit (to modify files) but configure a subagent to be read-only by not listing Edit in its tools. The main agent will not grant a subagent more permissions than it has – rather, subagents are equal or *more* restricted. If the main agent itself isn’t allowed to do something (like lacking permission to run docker, etc.), a subagent won’t magically bypass that unless explicitly allowed in configuration.

* In slash commands, the allowed-tools frontmatter acts as a mini permission set just for that command execution[\[46\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=,Create%20a%20git%20commit). The conversation’s overall allowed tools (which you manage via /permissions or startup flags) still apply as a baseline, but you can further tighten or loosen for the command. For example, you might normally disallow using the Bash tool without confirmation, but for a specific command that needs to run git status, you allow that one command. This granular control helps maintain safety while automating tasks.

* Claude Code also provides **Hooks** (pre-tool and post-tool hooks) to enforce rules or automatically run extra steps (like format code after edits). While not directly about commands or subagents, be aware you can set hooks in settings.json to, say, block certain file edits or ensure tests run after every commit[\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94)[\[47\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Hook%20A%20%E2%80%94%20block%20editing,sensitive%20files). This is an advanced safety net beyond the scope of this question, but it complements subagents/commands by providing guardrails (the Medium article’s example used hooks to prevent editing .env or running DB migrations in unsafe environments[\[48\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Hook%20A%20%E2%80%94%20block%20editing,sensitive%20files)[\[49\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,)).

**Summary:** Always review what tools your subagents and commands might use, and configure permissions accordingly. The goal is to let the AI execute useful actions autonomously but within boundaries you trust. By thoughtfully setting tools in subagent files and allowed-tools in command files (and global/project permissions), you strike a balance between efficiency and safety.

## Advanced Usage Patterns

With commands and subagents, you can craft sophisticated AI-driven workflows. Here are some advanced patterns to fully leverage them:

* **Orchestrating multi-step workflows:** You can chain tasks by using multiple subagents in sequence. For example, a common pattern is **Plan – Code – Test**:

* **Planning subagent** – e.g. planner that only reads and writes a plan (no code edits). You ask it to produce a design or list of steps for a feature. *“Use the planner subagent to outline how to add feature X.”* The planner (with maybe a large model) produces a plan (perhaps saved to a file like PLAN.md)[\[50\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Plan%20,run).

* **Coding subagent** – e.g. coder that has write access. After reviewing or approving the plan, you invoke *“Use the coder subagent to implement /docs/plan.md”*[\[51\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Implement%20After%20you%20approve%20the,plan). This agent reads the plan and makes the code changes accordingly (generating files, writing code, etc.). Its prompt can instruct it to follow the plan step by step.

* **Testing subagent** – e.g. test-runner that runs tests and fixes issues. Once coding is done, you say *“Use the test-runner subagent to run php artisan test and fix any failures”*[\[52\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix). This agent executes the test suite, analyzes failures, and applies minimal fixes to make tests pass, all within its allowed scope.

By splitting these roles, each subagent stays focused (planner never accidentally writes code, coder sticks to implementation, tester only fixes failing tests). The main agent helps pass outputs between them (or you do so by referencing files like the plan). This pattern was demonstrated in an end-to-end Laravel example[\[50\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Plan%20,run)[\[51\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Implement%20After%20you%20approve%20the,plan)[\[52\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix) and is a robust way to tackle complex tasks systematically. \- **Single-command orchestration:** If typing multiple commands is too manual, you can create a **single custom slash command that orchestrates multiple steps**. For instance, you might have a command /ship:feature that does everything “in one go” – plan, implement, migrate, test, etc. The content of such a command would include instructions covering each phase, possibly with \! to gather context (like checking environment, git status) and an extensive prompt telling Claude to use appropriate subagents or methods to complete all steps[\[53\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=3,do%20everything%20%E2%80%9Cin%20one%20go%E2%80%9D)[\[54\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=%23%23%20Context%20%28auto,s%20%7C%7C%20true). Essentially, this turns a multi-step process into one slash command. However, note that under the hood, Claude will still execute the steps sequentially and may ask for confirmations or produce intermediate output. Also, crafting such a prompt is tricky – you have to ensure it’s clear and the model doesn’t skip steps. It’s an advanced technique when you want automation with one trigger. Some community resources (like open-source command collections) show examples of these all-in-one workflow commands. \- **Mixing Commands and Subagents:** You can call subagents from within a command’s prompt text (in a descriptive way). For example, your command could say: *“First, use the code-reviewer subagent to review the changes, then summarize the findings.”* There’s no special syntax to *call* a subagent inside a command; rather, you are instructing Claude (the main agent) via the command’s prompt to go ahead and do that. If the command prompt is well-structured, Claude will follow those instructions and delegate to the subagent as if you had typed it yourself. Using the new @subagent mention inside the command prompt could also enforce a specific subagent at a certain point (though this is somewhat experimental). The key is that commands can include any instruction you want – including ones that leverage subagents. This essentially lets you create macro-tasks that involve multiple agents. Just remember that it will still happen turn by turn. \- **Model usage tuning:** As noted, you can choose which model each subagent or command uses. Advanced users might use the largest model for planning or for a code review agent (to utilize the largest context window for reviewing the whole codebase) but use a faster, cheaper model for trivial tasks or ones that don’t need as much “brainpower.” By configuring model in subagents/commands, you can optimize cost and speed per task. For example, set your lint command to use a smaller model since linting is straightforward, but your architect-planner agent to use Claude 2 for maximum context. \- **Memory and context bridging:** If you have important global context (like coding standards, style guides, etc.), you typically put that in CLAUDE.md (the project memory file loaded at session start). The main agent always has that in its system instructions[\[55\]](https://claudelog.com/faqs/restarting-claude-code/#:~:text=Every%20restart%20triggers%20%60CLAUDE.md%60%20re,while%20retaining%20previous%20memory%20updates). Subagents, however, won’t automatically have those same guidelines unless you include them in each subagent’s prompt or feed them in. An advanced pattern is to reference the memory file from the subagent when needed. For example, you could include a line in the subagent prompt like *“(Refer to the project guidelines in CLAUDE.md for coding standards.)”* – while the subagent might not have CLAUDE.md loaded by default, the main agent could pass on relevant parts if it’s clever. If that’s unreliable, you can keep critical guidelines duplicated in each subagent prompt (not DRY, but ensures consistency). There isn’t yet a built-in include for the project memory into each subagent, so consider that when designing subagent prompts. \- **Iterative refinement:** You can have the main agent and subagents work in tandem iteratively. For example, after a subagent does its task, you can ask the main agent to review or adjust it if needed. Or run another subagent. Because each subagent call is stateless (they don’t remember previous calls unless you give them info), you control the iteration loop from the main conversation. This is more a workflow note: you might loop through “test-runner \-\> fix \-\> test-runner \-\> fix” until tests pass, by repeatedly invoking the subagent after each fix, for instance.

In practice, you will mix and match these tools. A typical advanced session might go: use a custom command to set up context, automatically trigger a planner subagent, get approval, explicitly call a coder subagent, maybe run a built-in command like /review to get a final code review, etc. Claude Code’s flexibility means you can script quite elaborate sequences when needed.

## Limitations and Important Notes

While powerful, the commands and subagents system has some limitations and caveats to be aware of:

* **Session-bound Definitions:** As mentioned, **Claude Code reads your subagent and command files at startup**. If you add or modify a subagent or custom command file, the running session won’t know about the change. You’d have to exit and restart Claude Code to load the updated definitions[\[22\]](https://github.com/anthropics/claude-code/issues/4986#:~:text=Currently%2C%20subagents%20are%20only%20loaded,having%20to%20restart%20Claude%20Code). (There is no live reload of those files in the current version.) One workaround during development is to use the /agents interface to edit subagents, since that does update the file and presumably the session is aware after editing through the tool – but if you edit the file externally, a restart is safest.

* **No duplicate command names:** Ensure that a given command name is unique across your personal and project scopes. The system does not handle conflicts (e.g., if you have a deploy.md in both \~/.claude/commands and .claude/commands, one will shadow the other or it may cause an undefined behavior)[\[33\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Organize%20commands%20in%20subdirectories,level%20directory%20%28%60~%2F.claude%2Fcommands). Best practice is to keep personal commands as general utilities, and project commands with more specific or namespaced names to avoid overlap. Subagent names similarly should be unique; if you inadvertently create two subagents with the same name in the project directory, or both a user and project agent of same name, the project one “wins”[\[8\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Type%20Location%20Scope%20Priority%20Project,claude%2Fagents%2F%60Available%20across%20all%20projects%20Lower). It’s straightforward: one name \= one agent/command that Claude will use.

* **Subagent context limitations:** A subagent’s independent context is a double-edged sword. It avoids confusion, but it also means a subagent might **lack broader context**. If you call a subagent without giving it all necessary info, it might not know things that were only discussed in the main conversation or stored in main memory. You must ensure the prompt or task given to the subagent includes all details it needs (or that it can fetch via tools). For example, if the user just discussed some plan in the main thread and then says “Use the coder subagent to implement it,” the coder subagent will need to either have the plan provided (perhaps as an argument or it knows to read a plan.md file) – otherwise it’s working blind. Claude often helps by including recent instructions when delegating, but as a user, it’s wise to explicitly reference files or content the subagent should consider.

* **No hierarchical subagents:** Subagents themselves do not (at least by default) invoke other subagents. The chain of command is one level: main agent → subagent. A subagent won’t decide “this task needs an even more specialized agent” and call another; it will do the task itself. If you had a scenario where that seems needed, you as the user or through a custom command have to coordinate that (i.e., main agent calls one agent, then next). This keeps the architecture simpler and avoids runaway complexity.

* **Sequential execution and waiting:** As discussed, tasks happen one at a time. If a subagent’s operation takes a while (say it’s running a long bash command or analyzing a huge codebase), you have to wait for it to finish before anything else happens. You can’t give new instructions mid-way. You also cannot directly intervene in a subagent’s process except by letting it finish and then correcting or guiding via the main agent. If something is stuck, you might have to stop the session. (Claude Code may provide some “stop subagent” mechanism or you can Ctrl+C the process if truly necessary.)

* **Error handling:** If a subagent’s actions fail (maybe a Bash command errors out, or it can’t find a file), the main agent will receive that error. Often the main agent (Claude) will then either report the error or attempt to handle it (perhaps by giving an error message in the chat). Be prepared to troubleshoot just as you would with a human – e.g., if the test-runner subagent can’t run tests because the environment isn’t set up, you might need to fix the environment or adjust permissions and try again.

* **Cost and Performance:** Each subagent invocation is essentially a fresh query to the AI model with its own prompt and context. This means it will consume tokens from your quota and time to complete. Using many subagents or very verbose subagent prompts will use more tokens. Also, if you set some subagents to use the largest model, those calls will be slower and costlier. It’s usually worth it for the targeted benefit, but just be mindful of this especially in long sessions. The /cost command can show your token usage stats if needed[\[56\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=,Get%20usage%20help).

* **Maintaining subagents:** As your project evolves, you might need to update subagents (e.g., new tools, refined instructions). Remember to do so and restart as needed. Also, if Claude Code itself updates (they roll out new versions frequently), check the release notes – sometimes new tools or changes might allow you to simplify or improve your subagents. For example, if a new tool “Test” was added, you might incorporate that instead of using Bash for running tests, etc.

* **Modularity limitations:** Currently, subagent definitions don’t support including or importing other files directly (more on this in the next section). So, there may be some duplication in your subagents if they share common instructions. This is something to manage manually (perhaps script the generation of subagents or use a template if you have many similar ones).

Despite these limitations, commands and subagents, used wisely, provide a *powerful abstraction layer* between you and the raw AI. They let you encode processes and roles so that you can invoke complex behavior with simple instructions. It requires some upfront “prompt engineering” to set them up, but then they become reusable assets in your development workflow.

## Modularizing and Reusing Logic Across Agents/Commands

The user question specifically asks if one can put some of the agent or command logic into a separate Markdown file and include it from subagents or commands – effectively a modular design. This is an insightful idea for reducing repetition, and there are a couple of ways to achieve a form of modularity:

* **Using file references (@) as includes:** As discussed, for custom commands (and even in normal conversation with Claude Code), the @filename syntax is the primary way to include the full content of one file into another context[\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references). You can leverage this to keep large chunks of text or common instructions in dedicated files. For example, suppose you have a standard “coding style guidelines” paragraph that you want every code generation or review task to consider. You could store those guidelines in a file GUIDELINES.md. Then in your command or even in a user prompt you can write: *“Please follow our coding standards (see @GUIDELINES.md) when writing the code.”* Claude Code will replace that with the content of GUIDELINES.md when constructing the prompt, effectively injecting those guidelines without you copy-pasting them each time. This is a **dynamic include** at runtime, and it works wherever the AI is processing input (commands, normal prompts, etc.). So for **commands**, you can absolutely use this technique. Your command file might contain @common-prompt-snippet.md to pull in some boilerplate text. That way, if you need to update that snippet, you update the file in one place and all commands referencing it will get the new version next time they run.

Do note: The @ reference is resolved when the command is invoked (or when the user message is read). So if you change the included file, you don’t necessarily have to restart Claude Code – the next time you run the command, it will fetch the latest content of the included file (assuming Claude’s file index has picked up the change; you might use /reload or reopen the project if it caches a file list). There was a question on refreshing the file list if new files don’t appear for @ – usually Claude Code scans the project directory on start; adding a new file in a new folder might require a restart or using /add-dir if outside the known directories[\[57\]](https://docs.anthropic.com/en/docs/claude-code/common-workflows#:~:text=Common%20workflows%20,full%20content%20of%20the)[\[58\]](https://www.reddit.com/r/ClaudeAI/comments/1lsc4kx/how_to_refresh_files_list_to_reference_in_claude/#:~:text=How%20to%20refresh%20files%20list,files%20list%20to%20add%20it). So keep your included files within the project so they are recognized.

* **Subagent prompts modularity:** For subagents, their prompt is static content in the Markdown definition. The @ syntax is not documented to work inside the subagent definition file (and likely it won’t be automatically expanded there, since expansion typically happens for user messages and command invocations, not for reading an agent file itself). However, you can still achieve a modular effect by designing the subagent to read files at run-time:

For example, if you want a subagent to always consider GUIDELINES.md, you could include in its prompt: *“(You have access to the project guidelines. Make sure to read GUIDELINES.md for standards.)”* and ensure the subagent has the Read tool permission. The subagent, when invoked, might then on its own decide to open that file (Claude’s reasoning might do so if the prompt heavily suggests it). Alternatively, when you invoke the subagent explicitly, you can include the file via @ in your invocation. E.g., *“Use the code-reviewer subagent to review my changes. Our guidelines are: @GUIDELINES.md”*. In that invocation, the @GUIDELINES.md will expand before the subagent sees it, thus the subagent will get the guidelines in its input. This is a bit of a manual way to feed modular content to subagents on each use.

In short, **subagent definitions cannot directly import other files at definition time**, but you can use the main agent as the intermediary to provide modular info when calling the subagent.

* **CLAUDE.md for global context:** Claude Code’s design expects you to use the project memory file (CLAUDE.md) for overarching context and rules. The main agent always loads that, and it could indirectly influence subagents because the main agent might phrase the subagent’s invocation or provide context to it informed by CLAUDE.md. However, subagents don’t read CLAUDE.md themselves by default. If modular logic (like general rules) are critical to every agent, consider copying those rules into each subagent prompt for now, or rely on the main agent to pass them along. It’s duplication, but it ensures each agent is aware of them.

* **Shared utility commands:** Another form of modularity is to implement a piece of logic as a command that can be reused. For example, if you have a complex sequence to generate a report, instead of embedding that in many places, make it a command /generate-report. Then your other commands or your conversation can just call /generate-report as needed (even programmatically, though you as the user would have to invoke it). This way, the logic lives in one markdown file rather than scattered.

* **Template generation of agents/commands:** Some users manage large sets of subagents (like one per component or one per task). In such cases, maintaining them can be tedious. While not built into Claude Code, you could write scripts to generate your agent markdown files from a template (filling in certain fields). This is external to Claude, but worth mentioning as a way to keep things DRY (Don’t Repeat Yourself) if you end up with dozens of similar subagents.

In practice, the most straightforward modular approach is using @ file includes. That covers the majority of cases where you want to reuse or share content between agents/commands. For example, you could have:

* **PROMPT\_SNIPPETS/ directory:** containing markdown files for various common instructions (guidelines, legal notices, repetitive task instructions, etc.).

* In your command or even subagent invocation, use those with @. e.g., @PROMPT\_SNIPPETS/security\_guidelines.md to include the security section whenever you run a security review command or agent.

* This way, updating security\_guidelines.md updates the content everywhere it’s referenced, without editing each command/agent file.

Keep in mind that overly modular prompts can become harder to debug (since the actual assembled prompt is split across files). If something goes wrong, you have to remember that an included file might be the cause. Claude Code thankfully shows you the assembled prompt (in verbose mode or logs) so you can see what was fed to the model.

Finally, as Claude Code evolves, features may be added for better reusability (for example, maybe a future update allows subagents to inherit parts of CLAUDE.md or reference other agent files). Always check the latest documentation or community notes for new capabilities “as of right now.” As of mid-2025, the approaches described above are the ways to achieve modularity.

---

**In conclusion**, commands and subagents are powerful mechanisms to extend Claude Code’s functionality. **Subagents** allow you to split the AI into multiple roles, each with focused responsibilities, separate memory, and constrained permissions, improving reliability and organization of complex coding tasks[\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows)[\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94). They communicate with the main agent through a delegate-and-return pattern, keeping the main conversation cleaner and on track[\[3\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior). **Custom commands** let you encapsulate prompts and actions for one-shot reuse, including the ability to run shell commands and include file content seamlessly in the AI’s context[\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A)[\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references). Together, these features can be combined into advanced workflows – from automatically triggering the right subagent for a job, to chaining multiple subagents to handle a full development cycle.

We discussed how to reference subagents in conversation or within commands (by naming them or using @-mentions) to invoke them, how to reference files with @ to feed required data[\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references), and the importance of scopes and permissions in defining both commands and agents. We also covered how Claude Code reads these definitions (only at startup, requiring a restart on changes)[\[22\]](https://github.com/anthropics/claude-code/issues/4986#:~:text=Currently%2C%20subagents%20are%20only%20loaded,having%20to%20restart%20Claude%20Code) and some best practices for managing and modularizing your prompts for maintainability.

By mastering commands and subagents, you effectively become the “project manager” for your AI pair programmer, assigning it specialized helpers and giving it tools to be more efficient. As of now, this ecosystem is quite rich and continuing to grow (e.g., new features like subagent @-mentions and model selection per agent[\[12\]](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/#:~:text=needing%20to%20run%20a%20full,and%20losing%20important%20project%20context)). It’s worth staying updated via Anthropic’s release notes and community forums, but the core concepts remain: **a clear structure, proper scoping, and explicit instructions will let Claude Code’s agents and commands work together to greatly accelerate your coding tasks**. Enjoy building your AI “team”\!

**Sources:**

* Anthropic Claude Code Documentation – *Subagents*[\[3\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior)[\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows)[\[59\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields), *Slash Commands*[\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A)[\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references)[\[34\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Arguments), *Settings/Permissions*[\[60\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=You%20have%20two%20options%20for,configuring%20tools).

* Medium – Practical Guide to Claude Code Agents (Huq, 2025\)[\[61\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows)[\[51\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Implement%20After%20you%20approve%20the,plan)[\[52\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix).

* Reddit (ClaudeAI community) – Feature announcements for Claude Code (2025)[\[12\]](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/#:~:text=needing%20to%20run%20a%20full,and%20losing%20important%20project%20context).

---

[\[1\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,let%20you%20scale%20reliable%2C%20repeatable) [\[2\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows) [\[4\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94) [\[23\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=reviewer%20can%20read%2Fgrep%2C%20coder%20can,the%20natural%20unit%20for%20that) [\[26\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=In%20a%20single%20Claude%20Code,%E2%80%9CSubagent%20Stop%E2%80%9D%20hooks%20are%20described) [\[45\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=AnthropicClaudeLog%20,CLAUDE.md) [\[47\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Hook%20A%20%E2%80%94%20block%20editing,sensitive%20files) [\[48\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Hook%20A%20%E2%80%94%20block%20editing,sensitive%20files) [\[49\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,) [\[50\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Plan%20,run) [\[51\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Implement%20After%20you%20approve%20the,plan) [\[52\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix) [\[53\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=3,do%20everything%20%E2%80%9Cin%20one%20go%E2%80%9D) [\[54\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=%23%23%20Context%20%28auto,s%20%7C%7C%20true) [\[61\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,you%20scale%20reliable%2C%20repeatable%20workflows) Practical guide to mastering Claude Code’s main agent and Sub‑agents | by Md Mazaharul Huq | Jul, 2025 | Medium

[https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00)

[\[3\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior) [\[5\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior) [\[6\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure) [\[7\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20are%20stored%20as%20Markdown,frontmatter%20in%20two%20possible%20locations) [\[8\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Type%20Location%20Scope%20Priority%20Project,claude%2Fagents%2F%60Available%20across%20all%20projects%20Lower) [\[9\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields) [\[10\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,agents) [\[11\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,tools%20from%20the%20main%20thread) [\[13\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,all%20tools%20if%20omitted) [\[14\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Code%20reviewer) [\[15\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Review%20checklist%3A%20,Performance%20considerations%20addressed) [\[16\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Debugger) [\[17\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Debugging%20process%3A%20,Inspect%20variable%20states) [\[18\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Using%20the%20%2Fagents%20command%20) [\[19\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Define%20the%20subagent) [\[20\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=This%20opens%20an%20interactive%20menu,where%20you%20can) [\[21\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,tests%20and%20fix%20failures) [\[24\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Claude%20Code%20proactively%20delegates%20tasks,based%20on) [\[25\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Explicit%20invocation) [\[59\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields) [\[60\]](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=You%20have%20two%20options%20for,configuring%20tools) Subagents \- Anthropic

[https://docs.anthropic.com/en/docs/claude-code/sub-agents](https://docs.anthropic.com/en/docs/claude-code/sub-agents)

[\[12\]](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/#:~:text=needing%20to%20run%20a%20full,and%20losing%20important%20project%20context) New Claude Code features: Microcompact, enhanced subagents, and PDF support : r/ClaudeAI

[https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new\_claude\_code\_features\_microcompact\_enhanced/](https://www.reddit.com/r/ClaudeAI/comments/1mhrbzn/new_claude_code_features_microcompact_enhanced/)

[\[22\]](https://github.com/anthropics/claude-code/issues/4986#:~:text=Currently%2C%20subagents%20are%20only%20loaded,having%20to%20restart%20Claude%20Code) Feature Request: Dynamic Subagent Loading · Issue \#4986 · anthropics/claude-code · GitHub

[https://github.com/anthropics/claude-code/issues/4986](https://github.com/anthropics/claude-code/issues/4986)

[\[27\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Built) [\[28\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Project%20commands) [\[29\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Commands%20stored%20in%20your%20repository,project%29%E2%80%9D%20after%20their%20description) [\[30\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Personal%20commands) [\[31\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Location%3A%20) [\[32\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Conflicts%20between%20user%20and%20project,base%20file%20name%20can%20coexist) [\[33\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Organize%20commands%20in%20subdirectories,level%20directory%20%28%60~%2F.claude%2Fcommands) [\[34\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Arguments) [\[35\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A) [\[36\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=,issue.md) [\[37\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Execute%20bash%20commands%20before%20the,specific%20bash%20commands%20to%20allow) [\[38\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=) [\[39\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=For%20example%3A) [\[40\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=File%20references) [\[41\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=) [\[42\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=Thinking%20mode) [\[43\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=%3A,Inherits%20from%20the%20conversation) [\[44\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=command.%20Example%3A%20%60argument,Inherits%20from%20the%20conversation) [\[46\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=,Create%20a%20git%20commit) [\[56\]](https://docs.anthropic.com/en/docs/claude-code/slash-commands#:~:text=,Get%20usage%20help) Slash commands \- Anthropic

[https://docs.anthropic.com/en/docs/claude-code/slash-commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands)

[\[55\]](https://claudelog.com/faqs/restarting-claude-code/#:~:text=Every%20restart%20triggers%20%60CLAUDE.md%60%20re,while%20retaining%20previous%20memory%20updates) Restarting Claude Code | ClaudeLog

[https://claudelog.com/faqs/restarting-claude-code/](https://claudelog.com/faqs/restarting-claude-code/)

[\[57\]](https://docs.anthropic.com/en/docs/claude-code/common-workflows#:~:text=Common%20workflows%20,full%20content%20of%20the) Common workflows \- Anthropic API

[https://docs.anthropic.com/en/docs/claude-code/common-workflows](https://docs.anthropic.com/en/docs/claude-code/common-workflows)

[\[58\]](https://www.reddit.com/r/ClaudeAI/comments/1lsc4kx/how_to_refresh_files_list_to_reference_in_claude/#:~:text=How%20to%20refresh%20files%20list,files%20list%20to%20add%20it) How to refresh files list to reference in claude code : r/ClaudeAI

[https://www.reddit.com/r/ClaudeAI/comments/1lsc4kx/how\_to\_refresh\_files\_list\_to\_reference\_in\_claude/](https://www.reddit.com/r/ClaudeAI/comments/1lsc4kx/how_to_refresh_files_list_to_reference_in_claude/)